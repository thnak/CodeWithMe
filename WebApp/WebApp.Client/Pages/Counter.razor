@attribute [Route("/counter")]

<div class="row" >
    <div class="col-6 col-xs-12" >
        <h1>.NET Worker Multithreading</h1>

        Welcome to your new multithreaded app.

        <br /><br />
        Pi estimation demo. Specify number of iterations.<br />
        <MudNumericField @bind-Value="piIterations" T="int" ></MudNumericField>
        Specify number of workers to use.<br />
        <input @bind="workerNum" placeholder="Number of workers" type="text" /><br /><br />
        <button class="btn btn-primary" @onclick="OnClick" >Run Test</button><br />
        @foreach (var workerProgress in piProgress.Take(workerNum))
        {
            <progress max="100" value="@(workerProgress.Progress)" ></progress>
            <br />
        }

        <br />
        <br />
        <strong>Output:</strong>
        <hr />
        <pre>
@output
</pre>
    </div>
    <div class="col-6 col-xs-12" >
        <GithubSource RelativePath="Pages/BackgroundServiceMulti.razor" />
    </div>
</div>

<MudButton OnClick="@TryToRedirect" >Try redirect</MudButton>

@code {

    #region Models

    private class PiProgress
    {
        public int Progress { get; set; }
    }


    /// <summary>
    /// This service runs insinde the worker.
    /// </summary>
    private class MathsService
    {
        public event EventHandler<PiProgress> Pi;

        private IEnumerable<int> AlternatingSequence(int start = 0)
        {
            int i;
            bool flip;
            if (start == 0)
            {
                yield return 1;
                i = 1;
                flip = false;
            }
            else
            {
                i = (start * 2) - 1;
                flip = start % 2 == 0;
            }

            while (true) yield return ((flip = !flip) ? -1 : 1) * (i += 2);
        }

        public async Task<double> EstimatePI(int sumLength)
        {
            var lastReport = 0;
            await Task.Delay(100);
            return (4 * AlternatingSequence().Take(sumLength)
                .Select((x, i) =>
                {
                    // Keep reporting events down a bit, serialization is expensive!
                    var progressDelta = (Math.Abs(i - lastReport) / (double)sumLength) * 100;
                    if (progressDelta > 3 || i >= sumLength - 1)
                    {
                        lastReport = i;
                        Pi?.Invoke(this, new PiProgress() { Progress = i });
                    }

                    return x;
                })
                .Sum(x => 1.0 / x));
        }

        public double EstimatePISlice(int sumStart, int sumLength)
        {
            Console.WriteLine($"EstimatePISlice({sumStart},{sumLength})");
            var lastReport = 0;
            return AlternatingSequence(sumStart)
                .Take(sumLength)
                .Select((x, i) =>
                {
                    // Keep reporting events down a bit, serialization is expensive!
                    var progressDelta = (Math.Abs(i - lastReport) / (double)sumLength) * 100;
                    if (progressDelta > 3 || i >= sumLength - 1)
                    {
                        lastReport = i;
                        Pi?.Invoke(this, new PiProgress() { Progress = i });
                    }

                    return x;
                })
                .Sum(x => 1.0 / x);
        }
    }

    #endregion


    int piIterations = 5_000_000;
    int sliceSize;

    int _workerNum = 1;

    int workerNum
    {
        get => _workerNum;
        set
        {
            if (value < 1)
            {
                _workerNum = 1;
            }
            else if (value > 15)
            {
                _workerNum = 15;
            }
            else
            {
                _workerNum = value;
            }
        }
    }

    string output;

    public class ProgressRef
    {
        public int Progress { get; set; }
    }

    List<ProgressRef> piProgress = new();
    List<IWorker> workers = new();

    List<IWorkerBackgroundService<MathsService>> backgroundServices = new();

    string RunDisabled => Running ? "disabled" : null;
    bool Running = false;

    public async Task OnClick(EventArgs _)
    {
        Running = true;
        piProgress.ForEach(p => p.Progress = 0);
        output = "";
        var rn = Environment.NewLine;
        try
        {
            sliceSize = (int)Math.Floor((decimal)piIterations / workerNum);

            while (workers.Count() < workerNum)
            {
                output += $"{rn}{LogDate()} Initializing a worker.";
                StateHasChanged();
                var worker = await WorkerFactory.CreateAsync();
                workers.Add(worker);
                var service = await worker.CreateBackgroundServiceAsync<MathsService>();
                
                
                
                backgroundServices.Add(service);
                var progressRef = new ProgressRef();
                piProgress.Add(progressRef);
                await service.RegisterEventListenerAsync<PiProgress>(nameof(MathsService.Pi),
                    (_, eventInfo) =>
                    {
                        progressRef.Progress = (int)Math.Floor((100 * ((decimal)eventInfo.Progress / sliceSize)));
                        StateHasChanged();
                    });
            }

            var start = 0;
            var sw = new System.Diagnostics.Stopwatch();
            sw.Start();
            var allTasks = new List<Task<double>>();
            var servicesStarted = 0;
            foreach (var backgroundService in backgroundServices.Take(workerNum))
            {
                var end = start + sliceSize;

                var localStart = start;
                var localSliceSize = sliceSize;
                output += $"{rn}{LogDate()} Worker {servicesStarted + 1}: EstimatePISlice({localStart},{localSliceSize})...";
                var task = backgroundService.RunAsync(s => s.EstimatePISlice(localStart, localSliceSize));
                allTasks.Add(task);

                start = end;
                servicesStarted++;
            }

            var result = await Task.WhenAll(allTasks.ToArray()).ContinueWith(t => { return 4 * t.Result.Sum(); });

            sw.Stop();
            output += $"{rn}{LogDate()} All calls complete.";
            output += $"{rn}{LogDate()} EstimatePISlice({piIterations}) = {result}" +
                      $"{rn}   (Workers: {workerNum} Time: {sw.Elapsed})";
            piProgress.ForEach(p => p.Progress = 100);

            StateHasChanged();
        }
        catch (Exception e)
        {
            output = $"{rn}Error = {e}";
        }
        finally
        {
            Running = false;
        }
    }

    private string LogDate()
    {
        return DateTime.Now.ToString("HH:mm:ss:fff");
    }

    private async Task TryToRedirect()
    {
        var response = await ApiService.GetAsync<string>("/WeatherForecast/try-http-redirect");
        ToastService.ShowSuccess(response.Message);
    }

}